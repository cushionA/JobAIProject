using System;
using System.Collections.Generic;
using UnityEngine;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs;
using static JTestAIBase;
using static CombatManager;
using static JobAITestStatus;
using System.Runtime.CompilerServices;
using Unity.Mathematics;

/// <summary>
/// AITestJobの非JobSystem版実装
/// </summary>
public struct NonJobAI
{
    /// <summary>
    /// 読み取り専用のチームごとの全体ヘイト
    /// </summary>
    public NativeHashMap<int2, int> teamHate;

    /// <summary>
    /// CharacterDataDicの変換後
    /// </summary>
    public UnsafeList<CharacterData> characterData;

    /// <summary>
    /// 現在時間
    /// </summary>
    public float nowTime;

    /// <summary>
    /// 行動決定データ。
    /// ターゲット変更の反映とかも全部こっちでやる。
    /// </summary>
    public UnsafeList<MovementInfo> judgeResult;

    /// <summary>
    /// プレイヤー、敵、その他、それぞれが敵対している陣営をビットで表現。
    /// キャラデータのチーム設定と一緒に使う
    /// </summary>
    public NativeArray<int> relationMap;


    /// <summary>
    /// AIの判断を実行する
    /// </summary>
    public void ExecuteAIDecision()
    {
        // 各キャラクターについてAI判断を実行
        for ( int index = 0; index < characterData.Length; index++ )
        {
            // 結果の構造体を作成
            MovementInfo resultData = new MovementInfo();

            // 現在の行動のステートを数値に変換
            int nowMode = (int)characterData[index].liveData.actState;

            // 判断時間が経過したかを確認
            // 経過してないなら処理しない
            if ( nowTime - characterData[index].lastJudgeTime < characterData[index].brainData[nowMode].judgeInterval )
            {
                resultData.result = JudgeResult.何もなし;
                judgeResult[index] = resultData;
                continue;
            }

            // 行動条件の中で前提を満たしたものを取得するビット
            int enableCondition = 0;

            // 前提となる自分についてのスキップ条件を確認
            // 最後の条件は補欠条件なので無視
            for ( int i = 0; i < characterData[index].brainData[nowMode].actCondition.Length - 1; i++ )
            {

                SkipJudgeData skipData = characterData[index].brainData[nowMode].actCondition[i].skipData;

                // スキップ条件を解釈して判断
                if ( skipData.skipCondition == SkipJudgeCondition.条件なし || JudgeSkipByCondition(skipData, characterData[index]) == 1 )
                {
                    enableCondition |= 1 << i;
                }
            }

            // 条件を満たした行動の中で最も優先的なもの
            // 初期値は最後の条件、つまり条件なしの補欠条件
            int selectMove = characterData[index].brainData[nowMode].actCondition.Length - 1;

            // キャラデータを確認する
            for ( int i = 0; i < characterData.Length; i++ )
            {
                // 自分はスキップ
                if ( index == i )
                {
                    continue;
                }

                // 行動判断
                if ( enableCondition != 0 )
                {
                    for ( int j = 0; j < characterData[index].brainData[nowMode].actCondition.Length - 1; j++ )
                    {
                        // ある条件満たしたらbreakして、以降はそれ以下の条件もう見ない
                        if ( CheckActCondition(
                            characterData[index].brainData[nowMode].actCondition[j],
                            characterData[index],
                            characterData[i],
                            teamHate) )
                        {
                            selectMove = j;

                            // enableConditionのbitも消す
                            // i桁目までのビットをすべて1にするマスクを作成
                            int mask = (1 << j) - 1;

                            // マスクと元の値の論理積を取ることで上位ビットをクリア
                            enableCondition = enableCondition & mask;
                            break;
                        }
                    }
                }
                // 条件満たしたらループ終わり。
                else
                {
                    break;
                }
            }

            // 最も条件に近いターゲットを確認する
            // 比較用初期値はInvertによって変動
            TargetJudgeData targetJudgeData = characterData[index].brainData[nowMode].actCondition[selectMove].targetCondition;
            int nowValue = targetJudgeData.isInvert == BitableBool.TRUE ? int.MaxValue : int.MinValue;
            int newTargetHash = 0;

            // 状態変更の場合ここで戻る
            if ( targetJudgeData.judgeCondition == TargetSelectCondition.不要_状態変更 )
            {
                // 指定状態に移行
                resultData.result = JudgeResult.新しく判断をした;
                resultData.actNum = (int)targetJudgeData.useAttackOrHateNum;

                // 判断結果を設定
                judgeResult[index] = resultData;
                continue;
            }

            // それ以外であればターゲットを判断
            if ( targetJudgeData.judgeCondition == TargetSelectCondition.距離 )
            {
                // 自分の位置をキャッシュ
                float myPositionX = characterData[index].liveData.nowPosition.x;
                float myPositionY = characterData[index].liveData.nowPosition.y;

                // ターゲット選定ループ
                for ( int i = 0; i < characterData.Length; i++ )
                {
                    // 自分自身か、フィルターをパスできなければ戻る
                    if ( i == index || targetJudgeData.filter.IsPassFilter(characterData[i]) == 0 )
                    {
                        continue;
                    }

                    // マンハッタン距離で遠近判断
                    float distance = Math.Abs(myPositionX - characterData[i].liveData.nowPosition.x) +
                                    Math.Abs(myPositionY - characterData[i].liveData.nowPosition.y);

                    // 一番高いやつを求める
                    if ( targetJudgeData.isInvert == BitableBool.FALSE )
                    {
                        if ( distance > nowValue )
                        {
                            nowValue = (int)distance;
                            newTargetHash = characterData[i].hashCode;
                        }
                    }
                    // 一番低いやつを求める
                    else
                    {
                        if ( distance < nowValue )
                        {
                            nowValue = (int)distance;
                            newTargetHash = characterData[i].hashCode;
                        }
                    }
                }
            }
            else if ( targetJudgeData.judgeCondition == TargetSelectCondition.自分 )
            {
                newTargetHash = characterData[index].hashCode;
            }
            else if ( targetJudgeData.judgeCondition == TargetSelectCondition.プレイヤー )
            {
                // プレイヤーのハッシュはシングルトンから取得する想定
                // newTargetHash = characterData[i].hashCode;
            }
            else if ( targetJudgeData.judgeCondition == TargetSelectCondition.指定なし_ヘイト値 )
            {
                // ターゲット選定ループ
                for ( int i = 0; i < characterData.Length; i++ )
                {
                    // 自分自身か、フィルターをパスできなければ戻る
                    if ( i == index || targetJudgeData.filter.IsPassFilter(characterData[i]) == 0 )
                    {
                        continue;
                    }

                    // ヘイト値を確認
                    int targetHash = characterData[i].hashCode;
                    int targetHate = 0;

                    if ( characterData[index].personalHate.ContainsKey(targetHash) )
                    {
                        targetHate += (int)characterData[index].personalHate[targetHash];
                    }

                    int2 hateKey = new int2((int)characterData[index].liveData.belong, targetHash);

                    if ( teamHate.ContainsKey(hateKey) )
                    {
                        targetHate += teamHate[hateKey];
                    }

                    // 一番高いやつを求める
                    if ( targetJudgeData.isInvert == BitableBool.FALSE )
                    {
                        if ( targetHate > nowValue )
                        {
                            nowValue = targetHate;
                            newTargetHash = characterData[i].hashCode;
                        }
                    }
                    // 一番低いやつを求める
                    else
                    {
                        if ( targetHate < nowValue )
                        {
                            nowValue = targetHate;
                            newTargetHash = characterData[i].hashCode;
                        }
                    }
                }
            }
            // 通常のターゲット選定
            else
            {
                // ターゲット選定ループ
                for ( int i = 0; i < characterData.Length; i++ )
                {
                    // ハッシュを取得
                    if ( JudgeTargetByCondition(targetJudgeData, characterData[i], ref nowValue) == 1 )
                    {
                        newTargetHash = characterData[i].hashCode;
                    }
                }
            }

            // ここでターゲット見つかってなければ待機に移行
            if ( newTargetHash == 0 )
            {
                // 待機に移行
                resultData.result = JudgeResult.新しく判断をした;
                resultData.actNum = (int)ActState.待機;
                return;
            }

            resultData.result = JudgeResult.新しく判断をした;
            resultData.actNum = (int)targetJudgeData.useAttackOrHateNum;
            resultData.targetHash = newTargetHash;

            // 判断結果を設定
            judgeResult[index] = resultData;
        }
    }

    #region スキップ条件判断

    /// <summary>
    /// SkipJudgeConditionに基づいて判定を行うメソッド
    /// </summary>
    /// <param name="skipData">スキップ判定用データ</param>
    /// <param name="charaData">キャラクターデータ</param>
    /// <returns>条件に合致する場合は1、それ以外は0</returns>
    [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
    public static int JudgeSkipByCondition(in SkipJudgeData skipData, in CharacterData charaData)
    {
        SkipJudgeCondition condition = skipData.skipCondition;
        switch ( condition )
        {
            case SkipJudgeCondition.自分のHPが一定割合の時:
                // 各条件を個別に int で評価
                int equalConditionHP = skipData.judgeValue == charaData.liveData.hpRatio ? 1 : 0;
                int lessConditionHP = skipData.judgeValue < charaData.liveData.hpRatio ? 1 : 0;
                int invertConditionHP = skipData.isInvert == BitableBool.TRUE ? 1 : 0;
                // 明示的に条件を組み合わせる
                int condition1HP = equalConditionHP;
                int condition2HP = (lessConditionHP != 0) == (invertConditionHP != 0) ? 1 : 0;
                if ( condition1HP != 0 || condition2HP != 0 )
                {
                    return 1;
                }
                return 0;

            case SkipJudgeCondition.自分のMPが一定割合の時:
                // 各条件を個別に int で評価
                int equalConditionMP = skipData.judgeValue == charaData.liveData.mpRatio ? 1 : 0;
                int lessConditionMP = skipData.judgeValue < charaData.liveData.mpRatio ? 1 : 0;
                int invertConditionMP = skipData.isInvert == BitableBool.TRUE ? 1 : 0;
                // 明示的に条件を組み合わせる
                int condition1MP = equalConditionMP;
                int condition2MP = (lessConditionMP != 0) == (invertConditionMP != 0) ? 1 : 0;
                if ( condition1MP != 0 || condition2MP != 0 )
                {
                    return 1;
                }
                return 0;

            default:
                // デフォルトケース（未定義の条件の場合）
                Debug.LogWarning($"未定義のスキップ条件: {condition}");
                return 0;
        }
    }

    #endregion スキップ条件判断

    /// <summary>
    /// 行動判断の処理を隔離したメソッド
    /// </summary>
    /// <param name="conditions"></param>
    /// <param name="charaData"></param>
    /// <param name="nowHate"></param>
    [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
    public static bool CheckActCondition(in BehaviorData condition, in CharacterData myData, in CharacterData targetData, in NativeHashMap<int2, int> tHate)
    {
        bool result = true;

        // フィルター通過しないなら戻る。
        if ( condition.actCondition.filter.IsPassFilter(targetData) == 0 )
        {
            return false;
        }

        switch ( condition.actCondition.judgeCondition )
        {
            case ActJudgeCondition.指定のヘイト値の敵がいる時:

                int targetHash = targetData.hashCode;
                int targetHate = 0;

                if ( myData.personalHate.ContainsKey(targetHash) )
                {
                    targetHate += myData.personalHate[targetHash];
                }

                // チームのヘイトはint2で確認する。
                int2 hateKey = new int2((int)myData.liveData.belong, targetHash);

                if ( tHate.ContainsKey(hateKey) )
                {
                    targetHate += tHate[hateKey];
                }

                // 通常は以上、逆の場合は以下
                if ( condition.actCondition.isInvert == BitableBool.FALSE )
                {
                    result = targetHate >= condition.actCondition.judgeValue;
                }
                else
                {
                    result = targetHate <= condition.actCondition.judgeValue;
                }

                return result;

            // 集計は廃止
            //case ActJudgeCondition.対象が一定数の時:
            //    return HasRequiredNumberOfTargets(context);

            case ActJudgeCondition.HPが一定割合の対象がいる時:

                // 通常は以上、逆の場合は以下
                if ( condition.actCondition.isInvert == BitableBool.FALSE )
                {
                    result = targetData.liveData.hpRatio >= condition.actCondition.judgeValue;
                }
                else
                {
                    result = targetData.liveData.hpRatio <= condition.actCondition.judgeValue;
                }

                return result;

            case ActJudgeCondition.MPが一定割合の対象がいる時:

                // 通常は以上、逆の場合は以下
                if ( condition.actCondition.isInvert == BitableBool.FALSE )
                {
                    result = targetData.liveData.mpRatio >= condition.actCondition.judgeValue;
                }
                else
                {
                    result = targetData.liveData.mpRatio <= condition.actCondition.judgeValue;
                }
                return result;

            case ActJudgeCondition.設定距離に対象がいる時:

                // 二乗の距離で判定する。
                int judgeDist = condition.actCondition.judgeValue * condition.actCondition.judgeValue;

                // 今の距離の二乗。
                int distance = (int)(Mathf.Pow(targetData.liveData.nowPosition.x - myData.liveData.nowPosition.x, 2) +
                               Mathf.Pow(targetData.liveData.nowPosition.y - myData.liveData.nowPosition.y, 2));

                // 通常は以上、逆の場合は以下
                if ( condition.actCondition.isInvert == BitableBool.FALSE )
                {
                    result = distance >= judgeDist;
                }
                else
                {
                    result = distance <= judgeDist;
                }
                return result;

            case ActJudgeCondition.特定の属性で攻撃する対象がいる時:

                // 通常はいる時、逆の場合はいないとき
                if ( condition.actCondition.isInvert == BitableBool.FALSE )
                {
                    result = ((int)targetData.solidData.attackElement & condition.actCondition.judgeValue) > 0;
                }
                else
                {
                    result = ((int)targetData.solidData.attackElement & condition.actCondition.judgeValue) == 0;
                }
                return result;

            case ActJudgeCondition.特定の数の敵に狙われている時:
                // 通常は以上、逆の場合は以下
                if ( condition.actCondition.isInvert == BitableBool.FALSE )
                {
                    result = targetData.targetingCount >= condition.actCondition.judgeValue;
                }
                else
                {
                    result = targetData.targetingCount <= condition.actCondition.judgeValue;
                }
                return result;

            default: // 条件なし (0) または未定義の値
                return result;
        }
    }

    #region　ターゲット判断処理


    /// <summary>
    /// TargetConditionに基づいて判定を行うメソッド
    /// </summary>
    /// <param name="judgeData"></param>
    /// <param name="targetData"></param>
    /// <param name="score"></param>
    /// <param name="condition"></param>
    /// <returns></returns>
    // TargetConditionに基づいて判定を行うメソッド
    [MethodImplAttribute(MethodImplOptions.AggressiveInlining)]
    public static int JudgeTargetByCondition(in TargetJudgeData judgeData, in CharacterData targetData, ref int score)
    {
        TargetSelectCondition condition = judgeData.judgeCondition;
        int isInvert = judgeData.isInvert == BitableBool.TRUE ? 1 : 0;
        switch ( condition )
        {
            case TargetSelectCondition.高度:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }

                int height = (int)targetData.liveData.nowPosition.y;


                // 一番高いやつを求める (isInvert == 1)
                if ( isInvert == 0 )
                {
                    int isGreater = height > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = height;
                        return 1;
                    }
                }
                // 一番低いやつを求める (isInvert == 0)
                else
                {
                    int isLess = height < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = height;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.HP割合:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.hpRatio > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.hpRatio;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.hpRatio < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.hpRatio;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.HP:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.currentHp > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.currentHp;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.currentHp < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.currentHp;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.敵に狙われてる数:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.targetingCount > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.targetingCount;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.targetingCount < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.targetingCount;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.合計攻撃力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.dispAtk > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.dispAtk;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.dispAtk < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.dispAtk;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.合計防御力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.dispDef > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.dispDef;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.dispDef < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.dispDef;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.斬撃攻撃力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.atk.slash > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.atk.slash;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.atk.slash < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.atk.slash;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.刺突攻撃力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.atk.pierce > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.atk.pierce;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.atk.pierce < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.atk.pierce;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.打撃攻撃力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.atk.strike > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.atk.strike;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.atk.strike < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.atk.strike;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.炎攻撃力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.atk.fire > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.atk.fire;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.atk.fire < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.atk.fire;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.雷攻撃力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.atk.lightning > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.atk.lightning;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.atk.lightning < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.atk.lightning;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.光攻撃力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.atk.light > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.atk.light;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.atk.light < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.atk.light;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.闇攻撃力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.atk.dark > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.atk.dark;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.atk.dark < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.atk.dark;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.斬撃防御力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.def.slash > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.def.slash;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.def.slash < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.def.slash;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.刺突防御力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.def.pierce > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.def.pierce;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.def.pierce < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.def.pierce;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.打撃防御力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.def.strike > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.def.strike;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.def.strike < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.def.strike;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.炎防御力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.def.fire > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.def.fire;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.def.fire < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.def.fire;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.雷防御力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.def.lightning > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.def.lightning;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.def.lightning < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.def.lightning;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.光防御力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.def.light > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.def.light;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.def.light < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.def.light;
                        return 1;
                    }
                }
                return 0;

            case TargetSelectCondition.闇防御力:
                // フィルターをパスできなければ戻る。
                if ( judgeData.filter.IsPassFilter(targetData) == 0 )
                {
                    return 0;
                }



                // 一番高いやつを求める
                if ( isInvert == 0 )
                {
                    int isGreater = targetData.liveData.def.dark > score ? 1 : 0;
                    if ( isGreater != 0 )
                    {
                        score = targetData.liveData.def.dark;
                        return 1;
                    }
                }
                // 一番低いやつを求める
                else
                {
                    int isLess = targetData.liveData.def.dark < score ? 1 : 0;
                    if ( isLess != 0 )
                    {
                        score = targetData.liveData.def.dark;
                        return 1;
                    }
                }
                return 0;

            default:
                // デフォルトケース（未定義の条件の場合）
                Debug.LogWarning($"未定義のターゲット選択条件: {condition}");
                return 0;
        }
    }

    #endregion ターゲット判断処理


}